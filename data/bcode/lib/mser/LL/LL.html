<html>
<head><title>LL -  a double linked list library </title></head>
<body>
<h1>LL -  a double linked list library </h1>
<h2>NAME</h2>
<a href="#ApplyLL">ApplyLL</a>,
<a href="#ConsCopyLL">ConsCopyLL</a>,
<a href="#ConsLL">ConsLL</a>,
<a href="#ConsPtrLL">ConsPtrLL</a>,
<a href="#ConsistentLL">ConsistentLL</a>,
<a href="#DelElmLL">DelElmLL</a>,
<a href="#DelElmNeLL">DelElmNeLL</a>,
<a href="#DelElmPrLL">DelElmPrLL</a>,
<a href="#DestLL">DestLL</a>,
<a href="#EmptyLL">EmptyLL</a>,
<a href="#File2LL">File2LL</a>,
<a href="#FileNoExit2LL">FileNoExit2LL</a>,
<a href="#FirstElmLL">FirstElmLL</a>,
<a href="#ForeachDownLL_M">ForeachDownLL_M</a>,
<a href="#ForeachLL_M">ForeachLL_M</a>,
<a href="#FprintLL">FprintLL</a>,
<a href="#IndexElmLL">IndexElmLL</a>,
<a href="#InitLL">InitLL</a>,
<a href="#InsAftLL">InsAftLL</a>,
<a href="#InsAftLLf">InsAftLLf</a>,
<a href="#InsBefLL">InsBefLL</a>,
<a href="#InsBefLLf">InsBefLLf</a>,
<a href="#InsFirstLL">InsFirstLL</a>,
<a href="#InsFirstLLf">InsFirstLLf</a>,
<a href="#InsLastLL">InsLastLL</a>,
<a href="#InsLastLLf">InsLastLLf</a>,
<a href="#IsElmLL">IsElmLL</a>,
<a href="#IsEmptyLL">IsEmptyLL</a>,
<a href="#IsFirstElmLL">IsFirstElmLL</a>,
<a href="#IsLastElmLL">IsLastElmLL</a>,
<a href="#LL2ArrStr">LL2ArrStr</a>,
<a href="#LL2File">LL2File</a>,
<a href="#LastElmLL">LastElmLL</a>,
<a href="#LinkAftLL">LinkAftLL</a>,
<a href="#LinkBefLL">LinkBefLL</a>,
<a href="#LinkInsAftLL">LinkInsAftLL</a>,
<a href="#LinkInsAftLLf">LinkInsAftLLf</a>,
<a href="#LinkInsBefLL">LinkInsBefLL</a>,
<a href="#LinkInsBefLLf">LinkInsBefLLf</a>,
<a href="#LinkInsFirstLL">LinkInsFirstLL</a>,
<a href="#LinkInsFirstLLf">LinkInsFirstLLf</a>,
<a href="#LinkInsLastLL">LinkInsLastLL</a>,
<a href="#LinkInsLastLLf">LinkInsLastLLf</a>,
<a href="#LookInLL">LookInLL</a>,
<a href="#MoveHeadAftLL">MoveHeadAftLL</a>,
<a href="#MoveHeadBefLL">MoveHeadBefLL</a>,
<a href="#MoveHeadFirstLL">MoveHeadFirstLL</a>,
<a href="#MoveHeadLastLL">MoveHeadLastLL</a>,
<a href="#MoveListAftLL">MoveListAftLL</a>,
<a href="#MoveListBefLL">MoveListBefLL</a>,
<a href="#MoveListFirstLL">MoveListFirstLL</a>,
<a href="#MoveListLastLL">MoveListLastLL</a>,
<a href="#MoveTailAftLL">MoveTailAftLL</a>,
<a href="#MoveTailBefLL">MoveTailBefLL</a>,
<a href="#MoveTailFirstLL">MoveTailFirstLL</a>,
<a href="#MoveTailLastLL">MoveTailLastLL</a>,
<a href="#NextElmLL">NextElmLL</a>,
<a href="#NextCElmLL">NextCElmLL</a>,
<a href="#NthElmLL">NthElmLL</a>,
<a href="#PrevElmLL">PrevElmLL</a>,
<a href="#PrevCElmLL">PrevCElmLL</a>,
<a href="#ReadLL">ReadLL</a>,
<a href="#RelNthElmLL">RelNthElmLL</a>,
<a href="#RelCNthElmLL">RelCNthElmLL</a>,
<a href="#ReverseLL">ReverseLL</a>,
<a href="#SafeForeachLL_M">SafeForeachLL_M</a>,
<a href="#SizeLL">SizeLL</a>,
<a href="#SortLL">SortLL</a>,
<a href="#SscanLL">SscanLL</a>,
<a href="#UnlinkLL">UnlinkLL</a>,
<a href="#UnlinkNeLL">UnlinkNeLL</a>,
<a href="#UnlinkPrLL">UnlinkPrLL</a>,
<a href="#WriteLev1LL">WriteLev1LL</a>,
<a href="#WriteLev2LL">WriteLev2LL</a>,
<a href="#WriteLev3LL">WriteLev3LL</a>,
<a href="#WriteLevNLL">WriteLevNLL</a>,
<a href="#printLL">printLL</a>
<ul>
<li><a href="#.SHSYNOPSIS">SYNOPSIS </a> 
<li><a href="#.SHDESCRIPTION">DESCRIPTION </a> 
<menu>
<li><a href="#.SSListconstructionanddestruction">List </a> construction and destruction 
<li><a href="#.SSBasicfunctionsonlists">Basic </a> functions on lists 
<li><a href="#.SSRead/WriteTextFiles">Read/Write </a> Text Files 
<li><a href="#.SSReadingandWritingfrom/to.LLfile">Reading </a> and Writing from/to .LL file 
<li><a href="#.SSInsertingandDeletingelements">Inserting </a> and Deleting elements 
<li><a href="#.SSMovingListsandSublists">Moving </a> Lists and Sublists 
<li><a href="#.SSAccessingaparticularelement">Accessing </a> a particular element 
<li><a href="#.SSUnlinkingandLinking">Unlinking </a> and Linking 
<li><a href="#.SSMiscellaneousfunctions">Miscellaneous </a> functions 
<li><a href="#.SSPrint/Scanfunctions">Print/Scan </a> functions 
</menu>
<li>Example <a href="#.SHExampleexBasic">exBasic </a> 
<li>Example <a href="#.SHExampleexCutPaste">exCutPaste </a> 
<li>Example <a href="#.SHExampleexSortText-sortingafilealphabetically">exSortText </a> - sorting a file alphabetically 
<li>Example <a href="#.SHExampleexStruct-storing/accessingstructuresinthelist">exStruct </a> - storing/accessing structures in the list 
<li>Example <a href="#.SHExampleexPrintScan-usingSscanLL,printLLandFprintLL">exPrintScan </a> - using SscanLL, printLL and FprintLL 
<li>Example <a href="#.SHExampleexRead,exWrite-readingandwrittingintoan.LLfile">exRead, </a> exWrite - reading and writting into an .LL file 
<li>Example <a href="#.SHExampleexSortTime-testingspeedoftwosortalgorithms">exSortTime </a> - testing speed of two sort algorithms 
<li><a href="#.SHSEEALSO">SEE </a> ALSO 
<li><a href="#.SHBUGS">BUGS </a> 
<li><a href="#.SHAUTHOR">AUTHOR </a> 
</ul>
<h2><a name=".SHSYNOPSIS">SYNOPSIS </a> </h2>
<pre>
#include ''<a href= "file://localhost/user/eevsspsr/ees2gm/Soft/LL/inc/LL.h">LL.h</a>'' 

t_LL <a href="#ConsLL">ConsLL</a> (); 
t_LL   <a href="#InitLL">InitLL</a>(struct s_LL* head); 
t_LL <a href="#ConsCopyLL">ConsCopyLL</a>(t_LL dest); 
t_LL <a href="#ConsPtrLL">ConsPtrLL</a>(t_LL dest); 
void * <a href="#DestLL">DestLL</a>(t_LL list); 

t_LL   <a href="#EmptyLL">EmptyLL</a>  (t_LL list) 
int    <a href="#IsEmptyLL">IsEmptyLL</a>(t_LL list) 
t_LL   <a href="#ReverseLL">ReverseLL</a>(t_LL list) 
void * <a href="#ApplyLL">ApplyLL</a> (t_LL list, void * (*apply) (void *)) 
t_LL   <a href="#SortLL">SortLL</a> (t_LL list,  int (*compar) (void *, void*)) 
long   <a href="#SizeLL">SizeLL</a> (t_LL list); 
void * <a href="#LookInLL">LookInLL</a>(t_LL list); 

t_LL <a href="#File2LL">File2LL</a>(char * name);  
t_LL <a href="#FileNoExit2LL">FileNoExit2LL</a>(char * name);  
void <a href="#LL2File">LL2File</a>(t_LL list, char * name); 
char ** <a href="#LL2ArrStr">LL2ArrStr</a>(t_LL list); 

t_LL <a href="#ReadLL">ReadLL</a>(char * filename); 
void <a href="#WriteLev1LL">WriteLev1LL</a>(char * f_name, t_LL list); 
void <a href="#WriteLev2LL">WriteLev2LL</a>(char * f_name, t_LL list);  
void <a href="#WriteLev3LL">WriteLev3LL</a>(char * f_name, t_LL list); 
void <a href="#WriteLevNLL">WriteLevNLL</a>(char * f_name, t_LL list, int l); /* write list of lev l*/ 

#define <a href="#InsBefLL">InsBefLL</a>(p_el,data)   <a href="#InsBefLLf">InsBefLLf</a>(p_el,   sizeof(data), &amp;data) 
#define <a href="#InsAftLL">InsAftLL</a>(p_el,data)   <a href="#InsAftLLf">InsAftLLf</a>(p_el,   sizeof(data), &amp;data) 
#define <a href="#InsFirstLL">InsFirstLL</a>(list,data) <a href="#InsFirstLLf">InsFirstLLf</a>(list,   sizeof(data), &amp;data) 
#define <a href="#InsLastLL">InsLastLL</a>(list,data)  <a href="#InsLastLLf">InsLastLLf</a>(list,   sizeof(data), &amp;data) 

void * <a href="#InsBefLLf">InsBefLLf</a> (void * p_elm, size_t size, void * data); 
void * <a href="#InsAftLLf">InsAftLLf</a> (void * p_elm, size_t size, void * data); 
void * <a href="#InsFirstLLf">InsFirstLLf</a> (t_LL list, size_t size, void * data); 
void * <a href="#InsLastLLf">InsLastLLf</a> (t_LL list,  size_t size, void * data); 

#define <a href="#LinkInsBefLL">LinkInsBefLL</a>(p_el,data)   <a href="#LinkInsBefLLf">LinkInsBefLLf</a>(p_el, sizeof(data),&amp;(data)) 
#define <a href="#LinkInsAftLL">LinkInsAftLL</a>(p_el,data)   <a href="#LinkInsAftLLf">LinkInsAftLLf</a>(p_el, sizeof(data),&amp;(data)) 
#define <a href="#LinkInsFirstLL">LinkInsFirstLL</a>(list,data) <a href="#LinkInsFirstLLf">LinkInsFirstLLf</a>(list,sizeof(data),&amp;(data)) 
#define <a href="#LinkInsLastLL">LinkInsLastLL</a>(list,data)  <a href="#LinkInsLastLLf">LinkInsLastLLf</a>(list, sizeof(data),&amp;(data)) 

void * <a href="#LinkInsFirstLLf">LinkInsFirstLLf</a>(t_LL list, size_t size, void * newEl); 
void * <a href="#LinkInsLastLLf">LinkInsLastLLf</a>(t_LL list,  size_t size, void * newEl); 
void * <a href="#LinkInsAftLLf">LinkInsAftLLf</a>(void * curr, size_t size, void * newEl); 
void * <a href="#LinkInsBefLLf">LinkInsBefLLf</a>(void * curr, size_t size, void * newEl); 

void  <a href="#DelElmLL">DelElmLL</a>   (void * p_elm);   
void * <a href="#DelElmNeLL">DelElmNeLL</a>(void * p_elm);        
void * <a href="#DelElmPrLL">DelElmPrLL</a>(void * p_elm);        

t_LL  <a href="#MoveListFirstLL">MoveListFirstLL</a>(t_LL  dest, t_LL src); 
t_LL  <a href="#MoveListLastLL">MoveListLastLL</a>(t_LL  dest, t_LL src); 
void *  <a href="#MoveListAftLL">MoveListAftLL</a>(void *el,  t_LL src); 
void *  <a href="#MoveListBefLL">MoveListBefLL</a>(void *el,  t_LL src); 

t_LL  <a href="#MoveHeadFirstLL">MoveHeadFirstLL</a>(t_LL  dest, t_LL src, void *head); 
t_LL  <a href="#MoveHeadLastLL">MoveHeadLastLL</a>(t_LL  dest, t_LL src, void *head); 
void *  <a href="#MoveHeadAftLL">MoveHeadAftLL</a>(void *el,  t_LL src, void *head); 
void *  <a href="#MoveHeadBefLL">MoveHeadBefLL</a>(void *el,  t_LL src, void *head); 

t_LL  <a href="#MoveTailFirstLL">MoveTailFirstLL</a>(t_LL  dest, t_LL src, void *tail); 
t_LL  <a href="#MoveTailLastLL">MoveTailLastLL</a>(t_LL  dest, t_LL src, void *tail); 
void *  <a href="#MoveTailAftLL">MoveTailAftLL</a>(void *el,  t_LL src, void *tail); 
void *  <a href="#MoveTailBefLL">MoveTailBefLL</a>(void *el,  t_LL src, void *tail); 

void * <a href="#FirstElmLL">FirstElmLL</a> (t_LL list); 
void *  <a href="#LastElmLL">LastElmLL</a> (t_LL list); 
void *   <a href="#NthElmLL">NthElmLL</a> (t_LL list, long n); 
void *  <a href="#NextElmLL">NextElmLL</a> (void * p_elm); 
void *  <a href="#PrevElmLL">PrevElmLL</a> (void * p_elm); 
void *  <a href="#RelNthElmLL">RelNthElmLL</a> (void * p_elm, long n); 
void *  <a href="#NextCElmLL">NextCElmLL</a> (void * p_elm); 
void *  <a href="#PrevCElmLL">PrevCElmLL</a> (void * p_elm); 
void *  <a href="#RelCNthElmLL">RelCNthElmLL</a> (void * p_elm, long n); 

void * <a href="#LinkAftLL">LinkAftLL</a>(void * curr,void * new);   
void * <a href="#LinkBefLL">LinkBefLL</a>(void * curr,void * new);  
void * <a href="#UnlinkLL">UnlinkLL</a>(void * el); 
void * <a href="#UnlinkNeLL">UnlinkNeLL</a>(void * el); 
void * <a href="#UnlinkPrLL">UnlinkPrLL</a>(void * el); 

int   <a href="#IsElmLL">IsElmLL</a>  (void * p_elm); 
int   <a href="#IsFirstElmLL">IsFirstElmLL</a>  (void * p_elm);  
int   <a href="#IsLastElmLL">IsLastElmLL</a>   (void * p_elm); 
long  <a href="#IndexElmLL">IndexElmLL</a>    (t_LL list, void *ind_el); 

void <a href="#ConsistentLL">ConsistentLL</a>(t_LL list);  



<a href="#ForeachLL_M">ForeachLL_M</a>(list,p_elm) 
<a href="#ForeachDownLL_M">ForeachDownLL_M</a>(list,p_elm) 
<a href="#SafeForeachLL_M">SafeForeachLL_M</a>(list,p_elm,next_p_elm) 

char * <a href="#FprintLL">FprintLL</a>(t_LL list, FILE * file, char *b, char *control, char *a) ; 
char * <a href="#printLL">printLL</a>(t_LL list,  char * control); 
char * <a href="#SscanLL">SscanLL</a>(t_LL list, char *string, char * control, int termination); 
</pre>
<h2><a name=".SHDESCRIPTION">DESCRIPTION </a> </h2>
<h3><a name=".SSListconstructionanddestruction">List </a> construction and destruction </h3>
<a href= "file://localhost/user/eevsspsr/ees2gm/Soft/man2html/html/LL.html">LL</a> is a library implementing double-linked lists. 
Variables of any type can be stored in a <a href= "file://localhost/user/eevsspsr/ees2gm/Soft/man2html/html/LL.html">LL</a> list (without 
requiring the user to declare a new type  
[eg. containtaing 'link info' and 'data stored']) . 
As a consequence, lists of lists of .. (on so on to any depth)  can be created. 
Even individual elements of a single list may be of different types. 
<p>
An instance of a list is created using either <a name="ConsLL"><b>ConsLL</b></a>, <a name="ConsCopyLL"><b>ConsCopyLL</b></a>, <a name="InitLL"><b>InitLL</b></a> or 
<a name="ConsPtrLL"><b>ConsPtrLL</b></a> functions. It is recommended to call one of the functions at 
the point of declaration of a list variable; A list variable must be 
initialised by a call to one of the constructor functions before  
a list is passed to any function in the <a href= "file://localhost/user/eevsspsr/ees2gm/Soft/man2html/html/LL.html">LL</a> library.  
<p>
<a href="#ConsLL"><b>ConsLL</b></a>() creates an empty list. <a href="#ConsCopyLL"><b>ConsCopyLL</b></a>(src) creates a new copy 
of an existing list. <a href="#ConsPtrLL"><b>ConsPtrLL</b></a>(src) creates a list of pointers to 
elements stored  in list 'src'.  <a name="DestLL"><b>DestLL</b></a>(list) destroys a list, ie. deletes 
all elements and frees all memory allocated for the list (ie. the memory 
allocated by <a href="#ConsLL"><b>ConsLL</b></a>/<a href="#ConsCopyLL"><b>ConsCopyLL</b></a>/<a href="#ConsPtrLL"><b>ConsPtrLL</b></a> and by the 'insert element'  
family of functions).  Memory pointed to by elements of  the list is not 
freed. The use of <a href="#InitLL"><b>InitLL</b></a>() function assumes very good understanding of 
the implementation of the <a href= "file://localhost/user/eevsspsr/ees2gm/Soft/man2html/html/LL.html">LL</a> library and should be avoided by beginners. 
<a href="#InitLL"><b>InitLL</b></a> initializes a list similarly to <a href="#ConsLL"><b>ConsLL</b></a>, but the head of the list 
is stored in a structure provided by the user (rather than dynamically 
allocated as in <a href="#ConsLL"><b>ConsLL</b></a>). Lists created using <a href="#InitLL"><b>InitLL</b></a> must not be destroyed 
using <a href="#DestLL"><b>DestLL</b></a>, such list should only be emptied using <a name="EmptyLL"><b>EmptyLL</b></a>. 
<h3><a name=".SSBasicfunctionsonlists">Basic </a> functions on lists </h3>
<a href="#EmptyLL"><b>EmptyLL</b></a>(list) deletes all elements from  list 'list'. EmptyLL 
returns its parameter - an empty list 'list'. 
<p>
<a name="IsEmptyLL"><b>IsEmptyLL</b></a>(list) returns a non-zero value if 'list' is an empty list, 0 
otherwise. 
<p>
<a name="ReverseLL"><b>ReverseLL</b></a>(list) reverses the element order in a list. ReverseLL retruns 
its parameter. 
<p>
<a name="ApplyLL"><b>ApplyLL</b></a>(list,function) calls function 'function' in a loop. Pointers to 
elements of the list are one by one passed to 'function'. 
The loop is terminated when either pointers to all elements 
were passed to the function or the function 'function' returned a 
non-NULL value. <a href="#ApplyLL"><b>ApplyLL</b></a> returns NULL in the former case, an the return 
value of 'function' if it is non-NULL. If 'function' is  to be applied 
to all elements the user-defined  'function' must therefore always return NULL. 
The latter mode can be used as 'FindElement' if function 'function' returns a 
pointer to an element satisfying a certain condition. 
<p>
<a name="SizeLL"><b>SizeLL</b></a>(list) returns the number of elements in the list. The complexity of 
the function is O(n) (ie. the size of list is established by scanning 
through the list). 
<p>
<a name="SortLL"><b>SortLL</b></a>(list,compare) sorts elements of a list according to the 'compare' 
function. The 'compare' function has a format identical to the comparison  
function of <a href= "file:/usr/man/man3/qsort.3">qsort</a>(3). Two different sorting algorithms have been 
implemented. A fast mergesort provided by David Kastrup (MergeSortLL) and 
SysSortLL which  builds an array of pointers to list elements 
and then calls the standard C function <a href= "file:/usr/man/man3/qsort.3">qsort</a>(3).  
<a href="#SortLL"><b>SortLL</b></a> is mapped to MergeSortLL by a #define directive 
because in my tests MergeSortLL outperformed SysSortLL by a factor of two.  
The user can change the #define in <a href= "file://localhost/user/eevsspsr/ees2gm/Soft/LL/inc/LL.h">LL.h</a> to map <a href="#SortLL"><b>SortLL</b></a> to whichever sort 
is performing best on his machine/for his data. MergeSortLL and SysSortLL 
can be called directly. See examples 'exSortText' and 'exSortTime'  
in the EXAMPLE sections.  
<p>
<a name="LookInLL"><b>LookInLL</b></a>(list) creates a look-up table for list 'list' that enables random 
access to elements. If the type of elements in the list is 'int' than the 
type of the look-up table is of type int **table. *table[i] returns the 
value of the i-th element of 'list'. The ordering reflects the position of 
an element at the time of <a href="#LookInLL"><b>LookInLL</b></a> call. Sorting 'list' according to 
different criteria and creating a look-up table after every sort allows to 
order elements according to multiple criteria. It is an error to use the 
look-up table after any function that deletes elements from a list as any 
the pointer in 'table' can reference a deallocated part of memory.     
It is possible to use the table after any function that inserts, 
moves, changes value of list elements. *table[i] can be then interpreted as 
the value of the i-th element of list 'list' at the time of <a href="#LookInLL"><b>LookInLL</b></a> call 
regardless of the fact that the element may be in a different position or a 
member of a different list. The memory allocated by <a href="#LookInLL"><b>LookInLL</b></a> for the table 
should be freed by calling free(table). 
<h3><a name=".SSRead/WriteTextFiles">Read/Write </a> Text Files </h3>
<a name="File2LL"><b>File2LL</b></a>(name) opens a file and creates a list, each element holding 
a single line in a form of a zero terminated string.  
If the file cannot be opened, <a href="#File2LL"><b>File2LL</b></a> aborts the program. 
<a name="FileNoExit2LL"><b>FileNoExit2LL</b></a>(name) has the same functionality, but returns an empty 
list when on read/open file failure. <a name="LL2File"><b>LL2File</b></a>(list,name) outputs list 
contents to file name, one element per line. The list is assumed to  
contain zero-terminated strings. If '-' is passed as name  
stdin/stdout in used as the input/output file. 
<a name="LL2ArrStr"><b>LL2ArrStr</b></a>(list) assumes that the list holds zero-terminated strings. 
A NULL-terminated array of char* pointers to copies of these strings 
is returned. 
<h3><a name=".SSReadingandWritingfrom/to.LLfile">Reading </a> and Writing from/to .LL file </h3>
The <a name="ReadLL"><b>ReadLL</b></a> and Write....LL family of functions provide an external 
representation for lists. The <a name="WriteLev1LL"><b>WriteLev1LL</b></a> outputs a list of x, where x 
is any type besides a list, to a .LL file. If this file name is passed to 
<a href="#ReadLL"><b>ReadLL</b></a> a an identical list is recreated. So Write....LL in combination 
with <a href="#ReadLL"><b>ReadLL</b></a> can be used to transfer lists efficiently from one process 
to another. <a name="WriteLev2LL"><b>WriteLev2LL</b></a> writes out a list of lists of x (where x is any type 
besides a list), <a name="WriteLev3LL"><b>WriteLev3LL</b></a> writes out a list of lists of lists of x and 
<a name="WriteLevNLL"><b>WriteLevNLL</b></a> writes a list of lists etc. of depth N. <a href="#ReadLL"><b>ReadLL</b></a> will read a  
file written by any function of the Write....LL family. List containing  
pointers can be transferred in the same way (ie. the recreated list will 
contain fields for pointers), but the addresses contained in those fields 
are of no use. <a href="#ReadLL"><b>ReadLL</b></a>/Write....LL recognise the special name &quot;-&quot; as 
'standard input'/'standard output'. See 'exRead' and 'exWrite' for typical 
usage. 
<h3><a name=".SSInsertingandDeletingelements">Inserting </a> and Deleting elements </h3>
Macros <a name="InsBefLL"><b>InsBefLL</b></a>, <a name="InsAftLL"><b>InsAftLL</b></a>, <a name="InsFirstLL"><b>InsFirstLL</b></a>, <a name="InsLastLL"><b>InsLastLL</b></a> and functions 
<a name="InsBefLLf"><b>InsBefLLf</b></a>, <a name="InsAftLLf"><b>InsAftLLf</b></a>, <a name="InsFirstLLf"><b>InsFirstLLf</b></a>, <a name="InsLastLLf"><b>InsLastLLf</b></a> allow user to insert data 
of any type into a list. After <a href="#InsFirstLL"><b>InsFirstLL</b></a>(f)/<a href="#InsLastLL"><b>InsLastLL</b></a>(f), the new 
element will become the first/last element of a list.  Using 
<a href="#InsAftLL"><b>InsAftLL</b></a>(f)/<a href="#InsBefLL"><b>InsBefLL</b></a>(f), data can be inserted in an arbitrary place in 
a list after/before a given element. The functions (as opposed to 
macros) must be used when  size of the of the inserted object is not 
known at compilation time (for instance in the case of a 
zero-terminated string). Insert functions create a new element (element 
= stored object (data) + neccessary overhead (links etc.)) by 
allocating memory and copying the object in the element. 
<a name="LinkInsBefLL"><b>LinkInsBefLL</b></a>,<a name="LinkInsAftLL"><b>LinkInsAftLL</b></a> etc. functions operate 
exactly as their Ins....LL counterparts with the only difference that the 
user is responsible for allocating/declaring suitable structures for 
a list element (requires good knowledge of the <a href= "file://localhost/user/eevsspsr/ees2gm/Soft/man2html/html/LL.html">LL</a> library, not recommended 
for beginners).  
<p>
<a name="DelElmLL"><b>DelElmLL</b></a>, <a name="DelElmNeLL"><b>DelElmNeLL</b></a>, <a name="DelElmPrLL"><b>DelElmPrLL</b></a> delete an element from a list. DelElmNeLL 
returns a pointer to the next element, <a href="#DelElmPrLL"><b>DelElmPrLL</b></a> to the previous element. 
 'exBasic' shows typical usage of <a href="#DelElmLL"><b>DelElmLL</b></a>. 
<h3><a name=".SSMovingListsandSublists">Moving </a> Lists and Sublists </h3>
The Move family of functions can be used to cut and paste parts of lists. 
All Move functions have the same structure: MoveSomethingSomewhereLL. 
The structure MoveSomethingSomewhereLL is similar to the naming system 
of insert functions (eg. InsLastElmLL). MoveList___LL moves the whole source 
list (ie. the src list becomes empty)  somewhere (First,Last,Aft(er) 
element, Bef(ore)) into the destination list. The Head and Tail functions 
are analogous, but just Head (all elements up to (not including) the 'head' 
one)  or Tail(all elements from 'tail'(including) to end) is moved. The 
including/not including choice was made to preserve Head+Tail=List. 
<h3><a name=".SSAccessingaparticularelement">Accessing </a> a particular element </h3>
<a name="FirstElmLL"><b>FirstElmLL</b></a>(list)/<a name="LastElmLL"><b>LastElmLL</b></a>(list) return a pointer to the first element 
in 'list'. <a name="NextElmLL"><b>NextElmLL</b></a>(p_elm)/<a name="PrevElmLL"><b>PrevElmLL</b></a>(p_elm)  return a pointer to the 
next/previous element in 'list'. To access all elements in a list the 
following construct can be used: 
<p>
<pre>
for(pElm=<a href="#FirstElmLL">FirstElmLL</a>(list);<a href="#IsElmLL">IsElmLL</a>(pElm);pElm=<a href="#NextElmLL">NextElmLL</a>(pElm)) 
</pre>
<p>
The construct is used so often that the it is provided  in a form of 
the <a name="ForeachLL_M"><b>ForeachLL_M</b></a> macro. A similar macro, <a name="ForeachDownLL_M"><b>ForeachDownLL_M</b></a>, can be used to 
scan all the elements starting with the last. The user must ensure that 
the current 'pElm' is not deleted in the body of the for loop - the  
p_elm=<a href="#NextElmLL"><b>NextElmLL</b></a>(pElm) would fail. Use <a name="SafeForeachLL_M"><b>SafeForeachLL_M</b></a> in this case.  
<p>
<a name="NthElmLL"><b>NthElmLL</b></a>(list,n) returns a pointer to the n-th element of the list. 'n' can 
be negative. Note that the cost of the operations is proportional to 'n'; 
this functions should be therefore used sparingly; if random access to 
elements is required, use <a href="#LookInLL"><b>LookInLL</b></a>. <a name="RelNthElmLL"><b>RelNthElmLL</b></a>(p_elm,n) returns a pointer 
to an element with a distance (relative position) 'n' from 'p_elm'. See 
also the description and examples for RelCNthElmLLl). 
<a name="IndexElmLL"><b>IndexElmLL</b></a>(list,p_elm) returns the position (order) of 'p_elm' in 'list'. 
<p>
<a name="NextCElmLL"><b>NextCElmLL</b></a>(p_elm)/<a name="PrevCElmLL"><b>PrevCElmLL</b></a>(p_elm)  are analogous to 
<a href="#NextElmLL"><b>NextElmLL</b></a>(p_elm)/<a href="#PrevElmLL"><b>PrevElmLL</b></a>(p_elm), but the list is treated as circular. 
For a non-empty list, <a href="#NextCElmLL"><b>NextCElmLL</b></a>(p_elm) returns pointer to the 
next elment or, if 'p_elm' is the last element of the list, pointer to  
the first element. Similarly, <a href="#PrevCElmLL"><b>PrevCElmLL</b></a> returns pointer to the previous 
element or, if 'p_elm' points to the first element, pointer to the last element. 
For a non-empty list <a href="#NextCElmLL"><b>NextCElmLL</b></a>/<a href="#PrevCElmLL"><b>PrevCElmLL</b></a> skips the 
list head and always points to a genuine element and; the result need not 
be tested by <a name="IsElmLL"><b>IsElmLL</b></a>.  For an empty list the functions return pointer to 
the head. 
<p>
<a name="RelCNthElmLL"><b>RelCNthElmLL</b></a>(p_elm,n) returns a pointer to an element at distance  
(relative position) 'n' from 'p_elm' treating the list as circular -  
the 'head' is therefore not counted. So  
<pre>
  <a href="#RelCNthElmLL">RelCNthElmLL</a>(<a href="#FirstElmLL">FirstElmLL</a>(list),-1); 
</pre>
returns pointer to the last elment. In constrast,  
RelNthElm(<a href="#FirstElmLL"><b>FirstElmLL</b></a>(list),-1) returns pointer to the head. This is 
consistent with the <a href="#NthElmLL"><b>NthElmLL</b></a> and <a href="#LookInLL"><b>LookInLL</b></a> functions, where head is 
accessed as 0-th element. The result of RelNthElm(<a href="#FirstElmLL"><b>FirstElmLL</b></a>(list),-1)  
can be predicted by adding -1 to 1  (for the frist element). Zero  
is obtained and the corresponding element, the head, is returned. 
<h3><a name=".SSUnlinkingandLinking">Unlinking </a> and Linking </h3>
The Link...LL (<a name="LinkAftLL"><b>LinkAftLL</b></a>, <a name="LinkBefLL"><b>LinkBefLL</b></a>)  and Unlink..LL (<a name="UnlinkLL"><b>UnlinkLL</b></a>, <a name="UnlinkPrLL"><b>UnlinkPrLL</b></a>, 
<a name="UnlinkNeLL"><b>UnlinkNeLL</b></a>) family of functions allows to move individual  
elements between lists or to a different position in a list. The effect 
of Unlinking and Linking in at a different position is similar to 
first retrieving the element value, deleting the element and then  
inserting the element in the desired position. The advantages of 
Linking and Unlinking are: a. a significantly improved efficiency 
(eg. no malloc and free calls are needed) b. pointers to the elements are still valid if the element was moved 
through Link/Unlink (in the case of delete/insert the element is stored 
generally at  a different memory location and all pointers to it have 
to be reset). If a  number of elements is moved use one of the Move...LL  
functions instead. An example of Linking and Unlining is given in 
 'exSortTime'. <a href="#LinkAftLL"><b>LinkAftLL</b></a>/ <a href="#LinkBefLL"><b>LinkBefLL</b></a> link after and before a given element. 
<a href="#UnlinkLL"><b>UnlinkLL</b></a>, <a href="#UnlinkPrLL"><b>UnlinkPrLL</b></a>, <a href="#UnlinkNeLL"><b>UnlinkNeLL</b></a> perform the same operation, UnlinkLL 
retruns its argument, <a href="#UnlinkPrLL"><b>UnlinkPrLL</b></a> returns a pointer to the previous element 
and <a href="#UnlinkNeLL"><b>UnlinkNeLL</b></a> returns a pointer to the next element in the list. 
<h3><a name=".SSMiscellaneousfunctions">Miscellaneous </a> functions </h3>
<a href="#IsElmLL"><b>IsElmLL</b></a>(p_elm) tests for the end of a list.  <a name="IsFirstElmLL"><b>IsFirstElmLL</b></a>/<a name="IsLastElmLL"><b>IsLastElmLL</b></a> test 
for the first and last element of the list.  
<p>
<a name="ConsistentLL"><b>ConsistentLL</b></a>(list) runs a couple of check trying to establish whether 
the list is corrupted.  
<h3><a name=".SSPrint/Scanfunctions">Print/Scan </a> functions </h3>
It is fair to start this section with a WARNING: 
the functions bellow are NOT PORTABLE and NOT SAFE, if used 
for lists containing STRUCTURES.  Functions <a name="FprintLL"><b>FprintLL</b></a>, <a name="printLL"><b>printLL</b></a> and 
<a name="SscanLL"><b>SscanLL</b></a> work for list of any primitive types (int, char *, double, float, ..) 
and for structures that don't contain 'padding' bytes because of alignment 
requirments of its components 
(whether a structure contains these bytes is compiler/OS depend). 
  I recommend these functions be used only with a single 
conversion specification (eg. &quot;%s&quot; or &quot;%4.2g&quot;). Conversions strings with 
more than one specification should be used for DEBUGGING purposes 
(called directly from the debug. command line) or possibly 
for fast prototyping.  
<p>
<a href="#FprintLL"><b>FprintLL</b></a>(list,file,before,control,after) first writes string 'before' 
to 'file'. Then contents of all elements is output according to  
the 'control' string. Finally, the 'after' string is written to 'file'.  
With two exceptions, 
the control string is identical to the control string of the printf(3) 
family of functions. Because Fprintf must distinguish between double and 
float parameters, %lf, %lg, %le conversion were introduced for fields of type 
double. The %f, %g, %e conversions are used for fields of type float. The %S 
conversion is used for a zero-terminated string field. The %s is used for 
char* field (as in printf). Example usage is shown in examples 'exBasic', 
 'exCutPaste' and 'exPrintScan'. The format 
specification can contain printf(3) conversion flags, modifiers, etc. The 
field suppression character '*' may be used.  <a href="#FprintLL"><b>FprintLL</b></a> always returns 
NULL. 
<p>
<a href="#printLL"><b>printLL</b></a>(list,control)          is          identical           to 
<a href="#FprintLL"><b>FprintLL</b></a>(list,stdout,&quot;&quot;,control,&quot;\n&quot;). 
<p>
<a href="#SscanLL"><b>SscanLL</b></a>(list,string,control,termination) converts 'string' into structures 
defined by the control string and appends the structures to 'list'. The 
operation can be viewed as parsing of the string into a list of identical 
elements. The parsing is terminated either after converting a 'termination' 
number of elements (if 'termination' is positive) or after the end of 'string' 
was reached (if 'termination is 0). If 'termination' is equal to 
 -1, then the first token of 'string' defines the number of tokens 
converted. To skip data in 'string', use a conversion with '*' suppressing 
the assigment. See 'exPrintScan' for details. 
<h2>Example <a name=".SHExampleexBasic">exBasic </a> </h2>
<br>
<pre>
/*----------------- LL library example: basic functions ---------------- */ 
static char sccsid[]=&quot;@(#)94/01/03 g.matas@ee.surrey.ac.uk 6.2 exBasic.c&quot;; 


#include &quot;LL.h&quot; 
#include &lt;stdio.h&gt; 
#include &lt;string.h&gt; 


/*-----------------------------------------------------------------------*/ 
/*  
  This example shows HOW TO:  
    - create a list (<a href="#ConsLL">ConsLL</a>) 
    - insert elements into it at various positions (start, end, arbitrary)  
    - print out list contents (<a href="#ApplyLL">ApplyLL</a>) 
    - print out list using <a href="#printLL">printLL</a>, <a href="#FprintLL">FprintLL</a> (see warning in LL.h!) 
    - sort a list (<a href="#SortLL">SortLL</a>) 
    - iterate through a list (<a href="#ForeachLL_M">ForeachLL_M</a>) 
    - destroy (free) a list (<a href="#DestLL">DestLL</a>) 
*/ 
/*-----------------------------------------------------------------------*/ 
static void * pr(void *el)     /* print a string given a pointer to elem */ 
  { printf(&quot;%s  &quot;,*(char**)el); return NULL; } 


static 
int AlfComp(const void *el1, const void *el2)     /* comparison for sort */ 
 { return strcmp(*(char * const *) el1, *(char * const *) el2); } 


/*---------------------------------------------------------------------*/ 
int main (int argc, char ** argv) 
{ 
  t_LL list =  <a href="#ConsLL">ConsLL</a>(); 
  char  *string1 = &quot;s1&quot;;     /* some arbitrary strings .. */ 
  char  *string2 = &quot;s2&quot;; 
  char  *string3 = &quot;s3&quot;; 


  fprintf(stderr,&quot;usage: ex1 arg1 arg2 .... .... 0); 


  while (argc--&gt;0){ 
   <a href="#InsLastLL">InsLastLL</a>(list,argv[argc]); 
  } 


  printf(&quot;---- a list has been built from the command line  argu- 
ments: 0); 
  <a href="#ApplyLL">ApplyLL</a>(list,pr);  /* printing the whole list by appling pr to all elems.*/ 




  <a href="#InsFirstLL">InsFirstLL</a>(list,string1); 
  <a href="#InsLastLL">InsLastLL</a>(list,string2); 
  <a href="#InsBefLL">InsBefLL</a>(<a href="#NthElmLL">NthElmLL</a>(list,4),string3); 


  printf(&quot;0--  s1,s2 and s3 inserted ;  s1  first,  s2  last,  s3 
fourth:0); 
  <a href="#ApplyLL">ApplyLL</a>(list,pr); 




  <a href="#DelElmLL">DelElmLL</a>(<a href="#NthElmLL">NthElmLL</a>(list,3)); 
  <a href="#FprintLL">FprintLL</a>(list,stdout,&quot;0-- 3rd element deleted:0,&quot;%s  &quot;,&quot;0); 
				 /* another way to print out a list */ 


  <a href="#InsLastLL">InsLastLL</a>(list,string1); 
  <a href="#InsBefLL">InsBefLL</a>( <a href="#LastElmLL">LastElmLL</a>(list),string2); 
  printf(&quot;----     %s     inserted     as     last,     %s     as 
penultimate:0,string1,string2); 
  <a href="#printLL">printLL</a>(list,&quot;%s  &quot;);          /* yet another way to print a list */ 


  printf(&quot;0-- size of list: %ld0, <a href="#SizeLL">SizeLL</a>(list)); 


  <a href="#SortLL">SortLL</a>(list, AlfComp); 
  printf(&quot;---- sorted alphabetically:0); 
  <a href="#ApplyLL">ApplyLL</a>(list,pr); 


  { 
    char **listElem; 
    printf(&quot;0-- printf first char of each string: 0); 
    <a href="#ForeachLL_M">ForeachLL_M</a>(list,listElem) 
      printf(&quot;%c &quot;,(*listElem)[0]); 
   
    printf(&quot;0); 
  } 


  <a href="#DestLL">DestLL</a>(list);        /* clean up and quit */ 
  return 0; 
} 
</pre>
<p>
<p>
<h2>Example <a name=".SHExampleexCutPaste">exCutPaste </a> </h2>
<br>
<pre>
/*-------------- LL library example: cutting and pasting lists --------- */ 
static char sccsid[]=&quot;@(#)94/01/03 g.matas@ee.surrey.ac.uk 6.3 exCutPaste.c&quot;; 
#include &quot;LL.h&quot; 


/*-----------------------------------------------------------------------*/ 
/* 
  This example shows HOW TO: 
    - make a copy of a list (<a href="#ConsCopyLL">ConsCopyLL</a>)  
    - cut and paste a part of a list (Move..) 
    - sort a list (<a href="#SortLL">SortLL</a>) 
    - print a list (<a href="#printLL">printLL</a> &lt;read the note in <a href= "file://localhost/user/eevsspsr/ees2gm/Soft/LL/inc/LL.h">LL.h</a> on printLL usage&gt;) 
*/ 
/*-----------------------------------------------------------------------*/ 
static int CompDouble (const void * p_elm1,const  void *  p_elm2) 
{ return (* (double const *)p_elm1&lt;= * (double const *)p_elm2) ? -1 : 1 ; } 


/*-----------------------------------------------------------------------*/ 
int main (int argc, char ** argv) 
{ 
  double some_num [] = { 5.6, 3.9, 4.2, 6.7}; 
  double num; 


  t_LL   list = <a href="#ConsLL">ConsLL</a>();         /*                create an empty list  */ 


  {                     /* insert all numbers in some_num  into the list  */ 
  int i; 
  for (i=0; i &lt; sizeof(some_num)/sizeof(double); i++) 
    <a href="#InsLastLL">InsLastLL</a>(list,some_num[i]); 
  } 
			/* add some other numbers to the end of the list  */ 
  num = 7.15; <a href="#InsFirstLL">InsFirstLL</a>(list,num); 
  num = 8.80; <a href="#InsLastLL">InsLastLL</a>(list,num); 


  <a href="#FprintLL">FprintLL</a>(list,stdout,&quot;----        initial        list        of 
doubles:0,&quot;%4.2lg&quot;,&quot;0); 
	 
  {                                      
    t_LL copied_list = <a href="#ConsCopyLL">ConsCopyLL</a>(list); 


    <a href="#MoveListLastLL">MoveListLastLL</a>(list,copied_list); 
    <a href="#FprintLL">FprintLL</a>(list,stdout,&quot;---- list duplicated:0,&quot;%4.2lg&quot;,&quot;0); 
    <a href="#DestLL">DestLL</a>(copied_list); 
  }                                     /* end of copied list scope*/ 


  <a href="#SortLL">SortLL</a>(list,CompDouble); 
  <a href="#FprintLL">FprintLL</a>(list,stdout,&quot;---- list sorted :0,&quot;%4.2lg&quot;,&quot;0); 
     
  {                                            /* and Split now  */ 
    t_LL list2 = <a href="#MoveTailLastLL">MoveTailLastLL</a>(<a href="#ConsLL">ConsLL</a>(),list,<a href="#NthElmLL">NthElmLL</a>(list,6)); 


    printf(&quot;---- Cutting the list;0); 
    <a href="#FprintLL">FprintLL</a>(list   ,stdout,&quot;   Elements   1-5    (list    )    : 
&quot;,&quot;%4.2lg&quot;,&quot;0); 
    <a href="#FprintLL">FprintLL</a>(list2,stdout,&quot;    Elements     6-      (list2)     : 
&quot;,&quot;%4.2lg&quot;,&quot;0); 
     
    <a href="#MoveListFirstLL">MoveListFirstLL</a>(list,list2); 
    <a href="#MoveHeadFirstLL">MoveHeadFirstLL</a>(list2,list,<a href="#NthElmLL">NthElmLL</a>(list,3)); 
    <a href="#FprintLL">FprintLL</a>(list,stdout, 
       &quot;---- Elems 8- (3- elems of list2) inserted at the head of 
list:0, 
       &quot;%4.2lg&quot;,&quot;0 ); 
     
    <a href="#DestLL">DestLL</a>(list2);   /* destroy the list before it goes out of scope */ 
  } 
     
  <a href="#DestLL">DestLL</a>(list); 


  return 0;    
} 
</pre>
<p>
<h2>Example <a name=".SHExampleexSortText-sortingafilealphabetically">exSortText </a> - sorting a file alphabetically </h2>
<br>
<pre>
/*----------------- LL library example: sorting text  ------------------ */ 
static char sccsid[]=&quot;@(#)94/01/05 g.matas@ee.surrey.ac.uk 6.3 exSortText.c&quot;; 


#include &quot;LL.h&quot; 


#include &lt;stdio.h&gt;                                   /* for printf, gets etc */ 
#include &lt;string.h&gt;                                        /* for strcmp etc */ 


/*------------------ LL library example --------------------------------- 
    1.   Read in a text file from stdin  ( sort_ex  &lt;file) 
    2.   Sort line in alphabetical order 
    3.   print out  


-----------------------------------------------------------------------*/ 
static int sCmp(const void * s1, const void * s2) { return strcmp(s1,s2);} 


#define MAX_LINE_LENGTH 200 
int main(void) 
{ 
  char  buffer[MAX_LINE_LENGTH]; 
  t_LL list = <a href="#ConsLL">ConsLL</a>(); 


  fprintf(stderr,&quot;usage: exSortText &lt;infile &gt;outfile0 
		 &quot;  sorted text from stdin follows ----&gt;&quot;); 


  while(fgets(buffer,MAX_LINE_LENGTH,stdin)) 
    <a href="#InsLastLLf">InsLastLLf</a>(list,strlen(buffer)+1,buffer);   


  <a href="#SortLL">SortLL</a>(list, sCmp); 
  <a href="#printLL">printLL</a>(list,&quot;%S&quot;);         /* printing out the sorted file */ 


  return 0; 
} 
</pre>
<p>
<h2>Example <a name=".SHExampleexStruct-storing/accessingstructuresinthelist">exStruct </a> - storing/accessing structures in the list </h2>
<br>
<pre>
/*----- LL library example: list of user-def structures ---------------- */ 
static char sccsid[]=&quot;@(#)94/01/03 g.matas@ee.surrey.ac.uk 6.5 exStruct.c&quot;; 


#include &quot;LL.h&quot; 
#include &lt;stdio.h&gt; 


/*-----------------------------------------------------------------------*/ 
/* 
   put some numbers into a linked list 
   create a list of all pairs of numbers and print it out 
*/ 


/*-----------------------------------------------------------------------*/ 
static void * PrintInt(void * p_elm) 
	  { printf(&quot;%d &quot;,*(int*)p_elm); return NULL; } 


/*-----------------------------------------------------------------------*/ 
int main(int argc, char ** argv) 
{ 
  t_LL list  = <a href="#ConsLL">ConsLL</a>(); 
  t_LL pairs = <a href="#ConsLL">ConsLL</a>(); 
   
  int *n, *sec_num; 


  { /* insert all numbers in some_num  into the list  */ 
    int some_num [] = { 7, 3 , 8, 1, 19}; 
    int i; 
     
    for (i=0; i &lt; sizeof(some_num)/sizeof(int); i++) 
      <a href="#InsLastLL">InsLastLL</a>(list,some_num[i]); 


    printf(&quot;---- initial list of doubles:0); 
    <a href="#ApplyLL">ApplyLL</a>(list,PrintInt); 
    printf(&quot;0); 
  } 


  { 
    struct int_pair { int first; int second; } temp, *p_pair; 


    <a href="#ForeachLL_M">ForeachLL_M</a>(list,n) 
      for(sec_num = <a href="#NextElmLL">NextElmLL</a>(n); <a href="#IsElmLL">IsElmLL</a>(sec_num); sec_num= NextElmLL(sec_num)) 
      { 
	 temp.first    = *n; 
	 temp.second   = *sec_num; 
	 <a href="#InsLastLL">InsLastLL</a>(pairs,temp); 
      } 
	 
    printf(&quot;---- All (unordered) pairs: 0); 
    <a href="#ForeachLL_M">ForeachLL_M</a>(pairs,p_pair) 
     printf(&quot;%d-%d   &quot;,p_pair-&gt;first, p_pair-&gt;second); 
    printf(&quot;0); 
     
    <a href="#DestLL">DestLL</a>(pairs); 
  } 
  <a href="#DestLL">DestLL</a>(list); 


  return 0; 
} 
</pre>
<p>
<h2>Example <a name=".SHExampleexPrintScan-usingSscanLL,printLLandFprintLL">exPrintScan </a> - using SscanLL, printLL and FprintLL </h2>
<br>
<pre>
/*----------------- LL library example: printf/scanf use --------------- */ 
static char sccsid[]=&quot;@(#)94/01/03 g.matas@ee.surrey.ac.uk 6.2 exPrintScan.c&quot;; 


#include &quot;LL.h&quot; 
#include &lt;stdio.h&gt; 
/*-----------------------------------------------------------------------*/ 
/* 
   Warning:  
      before using <a href="#SscanLL">SscanLL</a>, <a href="#FprintLL">FprintLL</a>, <a href="#printLL">printLL</a>  
      Read the recommendation about thier use in LL.h! 
*/ 


/*-----------------------------------------------------------------------*/ 
int main(int argc, char ** argv) 
{ 
  t_LL num = <a href="#ConsLL">ConsLL</a>(); 
   
  char * some_num_str  = &quot; 7 3 8 1 21 25 19 10 10 10&quot;; 


  <a href="#SscanLL">SscanLL</a>(num,some_num_str,&quot;%d&quot;,0);         /* get numbers as ints */  
  printf(&quot;testing formats:0); 
  <a href="#FprintLL">FprintLL</a>(num,stdout,&quot;Plain  : &quot;,&quot;%d &quot;,&quot;0); 
  <a href="#FprintLL">FprintLL</a>(num,stdout,&quot;2digits: &quot;,&quot;%2d &quot;,&quot;0); 
  <a href="#FprintLL">FprintLL</a>(num,stdout,&quot;Element_a_line   :0,&quot;%d0,&quot;&quot;); 
  <a href="#FprintLL">FprintLL</a>(num,stdout,&quot;Elm= - : &quot;,&quot;%*d-&quot;,&quot;0); 
  printf(&quot;0); 
   
  <a href="#EmptyLL">EmptyLL</a>(num);                             /* remove old elms */ 
  <a href="#SscanLL">SscanLL</a>(num,some_num_str,&quot;%d %*d&quot;,0);     /* get odd order numbers as ints*/  
  <a href="#FprintLL">FprintLL</a>(num,stdout,&quot;Odd Pos: &quot;,&quot;%d &quot;,&quot;0); 


  <a href="#EmptyLL">EmptyLL</a>(num);                             /* remove old elms */ 
  <a href="#SscanLL">SscanLL</a>(num,some_num_str,&quot;%d&quot;,5);         /* get first 5  numbers as ints*/  
  <a href="#FprintLL">FprintLL</a>(num,stdout,&quot;1-5: &quot;,&quot;%d &quot;,&quot;0); 


  <a href="#DestLL">DestLL</a>(num);                      /* clean up, destroy list */  
  return 0; 
} 
</pre>
<p>
<h2>Example <a name=".SHExampleexRead,exWrite-readingandwrittingintoan.LLfile">exRead, </a> exWrite - reading and writting into an .LL file </h2>
<br>
<pre>
/*----------------- LL library example: writting out a list ------------ */ 
static char sccsid[]=&quot;@(#)94/01/03 g.matas@ee.surrey.ac.uk 6.2 exWrite.c&quot;; 
#include &quot;LL.h&quot; 


/*-----------------------------------------------------------------------*/ 
/* 
   1. Generate a list of doubles 
   2. Write it on the standard output in the .LL file format 
*/ 
/*-----------------------------------------------------------------------*/ 
int main (int argc, char ** argv) 
{ 
  t_LL   list = <a href="#ConsLL">ConsLL</a>();         /*                   create an empty list  */ 




  {                        /* insert all numbers in some_num  into the list  */ 
    int i; 
    double some_num [] = { 5.6, 3.9, 4.2, 6.7}; 


    for (i=0; i &lt; sizeof(some_num)/sizeof(double); i++) 
      <a href="#InsLastLL">InsLastLL</a>(list,some_num[i]); 
  } 
  
  <a href="#WriteLev1LL">WriteLev1LL</a>(&quot;-&quot;,list); 
     
  <a href="#DestLL">DestLL</a>(list); 
  return 0;    
} 


/*----------------- LL library example: reading an LL file ------------- */ 
static char sccsid[]=&quot;@(#)94/01/03 g.matas@ee.surrey.ac.uk 6.2 exRead.c&quot;; 


#include &quot;LL.h&quot; 


/*-----------------------------------------------------------------------*/ 
/* 
   Read a .LL file from standard input. 
   A list containing doubles is expected 
   Use exWrite to generated the correct file 
*/ 
/*-----------------------------------------------------------------------*/ 
int main (int argc, char ** argv) 
{ 
  t_LL   list = <a href="#ReadLL">ReadLL</a>(&quot;-&quot;);                  /* read a list from stdin */ 


  <a href="#printLL">printLL</a>(list,&quot;%4.2lf &quot;); 


  <a href="#DestLL">DestLL</a>(list); 
  return 0;    
} 
</pre>
<p>
<h2>Example <a name=".SHExampleexSortTime-testingspeedoftwosortalgorithms">exSortTime </a> - testing speed of two sort algorithms </h2>
<br>
<pre>
/*----------------- LL library example: sort (with timming) ------------ */ 
static char sccsid[]=&quot;@(#)94/01/03 g.matas@ee.surrey.ac.uk 6.4 exSortTime.c&quot;; 


#include &quot;LL.h&quot; 


#include &lt;stdio.h&gt;                                   /* for printf, gets etc */ 
#include &lt;stdlib.h&gt; 
#include &lt;time.h&gt; 


/*------------------------------------------------------------------------*/ 
static void MarkTime(char * point) 
{ 
  static float last=0; 
  float curr =clock()/(float)CLOCKS_PER_SEC; 


  fprintf(stderr,&quot;%6.2f  %6.2f  %s0,curr,curr-last,point); 
  last = curr; 
} 


/*------------------------------------------------------------------------*/ 
static int sCmp(const void * s1, const void * s2) 
{ return *(const int*)s1 - *(const int*)s2; } 


static void sort(int sortMethod, t_LL list) 
{                     /* sorting with timming prints */ 
  MarkTime(&quot;sort start&quot;); 
  switch (sortMethod) 
  { 
    case 1: MergeSortLL(list, sCmp); break; 
    case 2: SysSortLL(list, sCmp); break; 


    default: 
      fprintf(stderr,&quot;choose 1, 2, or 3 for the sorting alg.!0); 
      exit(1); 
  } 
  MarkTime(&quot;sort end&quot;); 
  printf(&quot;      check elems; 2nd: %d  999th: %d0, 
           *(int*)<a href="#NthElmLL">NthElmLL</a>(list,2), *(int*)NthElmLL(list,999)); 


}   


/*------------------ LL library example: sorting ------------------------*/ 
int main(int argc, char ** argv) 
{ 
  int numbers=10; 
  int sortMethod = 1; 


  int i; 
  t_LL list = <a href="#ConsLL">ConsLL</a>(); 


  if(argc!=3) 
  { 
    fprintf(stderr,&quot;usage:       msort_time.c        sorting_alg. 
number_of_ints_to_sort0 
                    &quot;   sorting_alg:  1-MergeSortLL   2-SysSortLL 
(ie.qsort) 0); 
    exit(-1); 
  } 


  sscanf(argv[1],&quot;%d&quot;,&amp;sortMethod ); 
  sscanf(argv[2],&quot;%d&quot;,&amp;numbers ); 


  srand(0);            /* for testing I want the random seq. not to change*/ 
  for(i=0;i&lt;numbers;i++) 
  {                      /* building a list of random numbers */ 
    int r = rand();      /* the randomness is really not that important */ 
    <a href="#InsLastLL">InsLastLL</a>(list,r); 
  } 


  printf(&quot;-------------------- sorting a random sequence 0); 
  sort(sortMethod,list); 


  printf(&quot;-------------------- sorting an already sorted list 0); 
  sort(sortMethod,list);     


  printf(&quot;-------------------- sorting a reversed list  0); 
  <a href="#ReverseLL">ReverseLL</a>(list); 
  sort(sortMethod,list);    


  <a href="#LinkAftLL">LinkAftLL</a>(<a href="#LastElmLL">LastElmLL</a>(list),  <a href="#UnlinkLL">UnlinkLL</a>(<a href="#FirstElmLL">FirstElmLL</a>(list))); 
			    /* unlink first and link it after last */ 
			    /* i.e. move the first element after the last */ 
  printf(&quot;-------------------- sort an almost sorted list,  first 
is last0); 
  sort(sortMethod,list);    /* sort list almost sorted (only first is last*/ 


  <a href="#ConsistentLL">ConsistentLL</a>(list); 


  return 0; 
} 


</pre>
<h2><a name=".SHSEEALSO">SEE </a> ALSO </h2>
<a href= "file:/usr/man/man3/qsort.3">qsort</a>(3), examples provided with the <a href= "file://localhost/user/eevsspsr/ees2gm/Soft/man2html/html/LL.html">LL</a> installation 
<h2><a name=".SHBUGS">BUGS </a> </h2>
<h2><a name=".SHAUTHOR">AUTHOR </a> </h2>
George (Jiri) <a href= "file://localhost/user/eevsspsr/ees2gm/html/home.html">Matas</a>, University of Surrey, g.matas@ee.surrey.ac.uk.  
<p>
The idea of representing a list by a circular list with a dummy 
node was picked form the Anasazi Linked List Utilities by Duane Morse 
(duane@anasaz). The MergeSort code was kindly provided by David 
Kastrup(dak@pool.informatik.rwth-aachen.de). The design of this 
library was influenced by numerous discussion with Radek <a href= "file://localhost/user/eevsspsr/ees1rm/html/home.html">Marik</a>  
(r.marik@ee.surrey.ac.uk).  
<HR><ADDRESS>
17-Feb-95. Automatically converted by man2html,
 written by G.Matas (g.matas@ee.surrey.ac.uk)</ADDRESS>
</body>
</html>
